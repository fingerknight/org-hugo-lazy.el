* Org Hugo Lazy
Org hugo lazy (ohl) is an Emacs tool to publish org files to *GitHub Page* as blog by using [[https://gohugo.io][Hugo]] and [[https://github.com/kaushalmodi/ox-hugo][ox-hugo]].

** Installation
Needed: ~Emacs >= 28.2~, ~Org Mode >= 9.5.5~

1.Install ~Hugo~
Please go to [[https://gohugo.io/getting-started/installing/]] to install Hugo according to your system.

2.Install ~ox-hugo~
~M-x packag-install RET ox-hugo~

3.Install ~emacsql~
SQLite is used as cache, make sure you have own it.

~M-x packag-install RET eamcsql~

4.Install ~f.el~ and ~s.el~
They are fantastic Emacs API. ~M-x packag-install RET f~, ~M-x packag-install RET s~.
   
5.CLone or download this tool. Add it to your ~init.el~
#+begin_src elisp
  (add-to-list 'load-path "<where ohl is>")
  (require 'ohl)
#+end_src
Since packages are lazy-loaded, don't worry about being slow down by ~ohl~

6.(Unnecessary) Since my blog uses [[https://github.com/gitalk/gitalk/][Gitalk]] as comment system, so I add this process to ~ohl~
Install [[https://github.com/cli/cli][GitHug CLI]] to add new issue automatically.
#+begin_src bash
  sudo pacman -S github-cli
#+end_src

** Usage
*** ohl configuration
#+begin_src elisp
  (require 'ohl)

  ;; Where to save the cache data
  ;; Default: ~/.emacs.d/org-hugo-lazy.db
  ;; (setq ohl-db-path (f-expand "org-hugo-lazy.db" user-data-directory))

  (setq ohl-project-plist
	;; This is a project
	'(("blog"
	   :base-directory "~/org/blog/"
	   :source-directory "~/org/posts/"
	   :repository-directory "~/org/"
	   :static-relative-directory "assets"
	   :gitalk t
	   :url "https://example.github.io/"
	   :paried-shortcodes "mermaid admonition"
	   :auto-lastmod t
	   :with-toc nil
	   )
	;; This is another project
	  ;; ("emacs"
	  ;;  ...
	  ;;  )
	  ))

#+end_src

- ~:base-directory~: directory of Hugo project.
- ~:source-directory~: where your ~org~ files locate
- ~:repository-directory~: your GitHub repo in locality.
- (optional) ~:static-relative-directory~: the relative path of static files to ~/~. Suppose it is set to be ~assets~ as above, and there is a image named ~some.png~, then it will be copied into ~<your hugo project>/static/assets/some.png~ when exporting. Default
- (optional) ~:gitalk~: if it is ~t~, then ~ohl~ will try to add a new issue to your GitHub Page as a comment system of your blog. Default is ~nil~.
- (optional) ~:url~: url of your blog. *But it is necessary if ~:gitalk~ is ~t~.* No default
- ~:paried-shortcodes~: Allowed custom Hugo Shortcodes, each of them are seperated by space ~" "~. Default is "mermaid admonition".
- ~:auto-lastmode~: If automatically update the ~last-modification~ date. Default is ~t~.
- ~:with-toc~: If posts are exported with table of content. Default is ~nil~ (since my Hugo Theme will handle toc).

*** ohl APIs
**** ohl-load-all
Since loading ~ox~ package and SQLite cache may cost a lot of startup time, I set them to be lazy-loaded, i.e., they load when ~ohl-load~ is called. You don't have to call it manually, other APIs will do implicitly.

**** ohl-generate 
To transform all the ~org~ files in ~ohl-source-dir~ to ~md~ recursively. It will check the *last modified date* of files, then skip the unmodified file -- by comparing with data in cache.

Firstly, it will try to load packages and cache by ~ohl-load-all~.

~ohl-generate~ accpet a parameter ~plist~ which is the project of ~ohl-project-plist~. And it trys to add new issues to GitHub Repo. Note that it will *not* do things about GitHub isseue even ~:gitalk~ is ~t~ when *interactively*. 

With ~ohl-auto-gitalk~ as ~t~, if ~ohl-generate~ is called interactively, then it only transform files, not handling ~Github Issue~. Otherwise, it will try to create new issue for each ~org~ file since ~Gitalk~ use issues as comment system of blog.

**** ohl-publish
~ohl-publish~ do a little more than ~ohl-generate~: accepted a project, it calls ~ohl-generate~, publishes the site by CLI ~hugo~, and git commit the files to GitHub Repo. Actually, to push the things, it will create a ~shell~ script in ~ohl-git-commit-shell-path~ with content ~ohl-git-script-template~, and execute it.

**** ohl-publish-all
It will try to publish all the projects in ~ohl-project-plist~.

** How it works
Here is the design of ~ohl~.

*** Procedure
Suppose that ~ohl-auto-gitalk~ is ~t~.

Firstly it will get issue list of GitHub repo by ~gh issue list~, and extract out all the issue with label ~Gitalk~.

Scan each file in ~ohl-source-dir~, calling function in ~ox-hugo~ -- ~org-hugo-export-wim-to-md~ to transform current ~org~ file to ~md~. Meanwhile, it will calculate the MD5 of the string, the /relative path/ of output ~md~ file to ~<your hugo project dir>/content~. The MD5 is the unique ID, so that each post in blog can match the correct GitHub Issue.

The explanation of /relative path/. Assume your Hugo project directory is ~blog~, and your output ~md~ locates in ~blog/content~.
#+begin_src
blog/content/about.md => about.md
blog/content/posts/just-a-post.md => posts/just-a-posts.md
#+end_src

Try to create a new label by ~gh label create [md5 of relative path]~, then try to create a new issue by ~gh issue create --title [post's title] --body [post's url in your blog] --label "Gitalk,[md5 of relative path]"~. If network errors occur, they may work improperly.

Call ~hugo~ to publish ~md~ file to ~html~.

Try to ~git add/commit/push~ files to GitHub.

*** Cache
~TODO~:
- [X] all the projects' data saves in one database, with RELATIVE_FILENAME as /unique key/, which means ~project1/posts/index.org~ may affect ~project2/posts/index.org~.

Cache is a ~SQLite~ databaes with a table ~data~ consisting of
| Name     | Type    | For                                |
|----------+---------+------------------------------------|
| ID       | Integer | Primary Key                        |
| FILE     | String  | relative name of `org' file        |
| LASTMOD  | Integer | Last modificationTimestamp of file |
| NOT_KILL | Integer | Wether to delete this item         |
Explanation of ~NOT_KILL~.

They are both set to be 0 in database. Each ~org~ file will generate or update an item, setting ~NOT_KILL~ to 1, no matter if they are modified or not. At the last of generating, it remove all the item in database whose ~NOT_KILL~ is 0, which means they are old files that doesn't exixt in current project. Then set all left items' ~NOT_KILL~ to 0.
